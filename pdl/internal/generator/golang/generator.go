package golang

import (
	"context"
	"fmt"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/gobeam/stringy"

	"github.com/kapablanka/pdl/pdl/internal/ast"
	"github.com/kapablanka/pdl/pdl/internal/generator"
)

const generatorName = "go"

var goTypeMap = map[string]string{
	generator.TypeString:   "string",
	generator.TypeBool:     "bool",
	generator.TypeInt:      "int",
	generator.TypeUInt:     "uint",
	generator.TypeDouble:   "float64",
	generator.TypeArray:    "[]interface{}",
	generator.TypeFunction: "func()",
	generator.TypeObject:   "any",
}

type Generator struct {
	generator.Base
}

func init() {
	generator.Register(generatorName, func(ctx context.Context, document ast.Document, options generator.Options) generator.Generator {
		instance := &Generator{Base: generator.NewBase(goTypeMap)}
		instance.Initialize(ctx, document, options)
		return instance
	})
}

func (Generator) Name() string {
	result := generatorName
	return result
}

func (goGen *Generator) Generate() error {
	document := goGen.Document()
	namespaceDir := namespacePath(goGen.OutputDir(), document.Namespace.Name.Segments)
	if err := goGen.EnsureDir(namespaceDir); err != nil {
		return err
	}
	packageName := packageFromNamespace(document.Namespace.Name.QualifiedName)
	handler := func(classNode ast.Class) error {
		contextData := goClassContext{
			packageName: packageName,
			namespace:   document.Namespace,
			classNode:   classNode,
			targetDir:   namespaceDir,
		}
		return goGen.generateClassFile(contextData)
	}
	return goGen.ForEachClass(handler)
}

func namespacePath(root string, segments []string) string {
	parts := make([]string, 0, len(segments)+1)
	parts = append(parts, root)
	for _, segment := range segments {
		parts = append(parts, strings.ToLower(segment))
	}
	result := filepath.Join(parts...)
	return result
}

func packageFromNamespace(qualified string) string {
	if qualified == "" {
		return "main"
	}
	if last := strings.LastIndex(qualified, "."); last >= 0 && last+1 < len(qualified) {
		qualified = qualified[last+1:]
	}
	result := strings.ToLower(qualified)
	return result
}

type goClassContext struct {
	packageName string
	namespace   ast.Namespace
	classNode   ast.Class
	targetDir   string
}

func (goGen *Generator) generateClassFile(contextData goClassContext) error {
	var result error
	content, contentErr := goGen.buildClassSource(contextData.packageName, contextData.namespace, contextData.classNode)
	if contentErr != nil {
		result = contentErr
		return result
	}
	fileName := exportedName(contextData.classNode.Name) + ".go"
	filePath := filepath.Join(contextData.targetDir, fileName)
	goGen.WriteFile(filePath, []byte(content))
	if err := runGoFmt(filePath); err != nil {
		result = err
		return result
	}
	return result
}

func (goGen *Generator) buildClassSource(packageName string, namespace ast.Namespace, classNode ast.Class) (string, error) {
	builder := new(strings.Builder)
	builder.WriteString("// Code generated by pdlgen. DO NOT EDIT.\n")
	builder.WriteString("package " + packageName + "\n\n")
	imports := goGen.collectImports(namespace, classNode)
	if len(imports) > 0 {
		writeImportBlock(builder, imports)
		builder.WriteString("\n")
	}
	constants := goGen.collectConstMembers(classNode)
	if len(constants) > 0 {
		writeConstBlock(builder, constants)
		builder.WriteString("\n")
	}
	properties, propErr := goGen.collectProperties(classNode)
	if propErr != nil {
		return "", propErr
	}
	embedded := embeddedType(classNode)
	writeStruct(builder, classNode.Name, embedded, properties)
	methods := goGen.collectMethods(classNode)
	if len(methods) > 0 {
		builder.WriteString("\n")
		for index, method := range methods {
			builder.WriteString(method)
			if index+1 < len(methods) {
				builder.WriteString("\n")
			}
		}
	}
	return builder.String(), nil
}

type constEntry struct {
	Name  string
	Type  string
	Value string
}

func (goGen *Generator) collectConstMembers(classNode ast.Class) []constEntry {
	result := make([]constEntry, 0)
	for _, member := range classNode.Members {
		if member.Kind != "const" {
			continue
		}
		typeInfo, err := member.ConstType()
		if err != nil {
			continue
		}
		value := literalValue(member.Value)
		if value == "" {
			continue
		}
		entry := constEntry{
			Name:  exportedName(member.Name),
			Type:  goGen.goTypeFromIdentifier(typeInfo),
			Value: value,
		}
		result = append(result, entry)
	}
	sort.SliceStable(result, func(left int, right int) bool {
		return result[left].Name < result[right].Name
	})
	return result
}

type propertyEntry struct {
	Name string
	Type string
	Tag  string
}

func (goGen *Generator) collectProperties(classNode ast.Class) ([]propertyEntry, error) {
	result := make([]propertyEntry, 0)
	for _, member := range classNode.Members {
		if member.Kind != "property" && member.Kind != "shortProperty" {
			continue
		}
		propType, err := member.PropertyType()
		if err != nil {
			return result, err
		}
		typeName := goGen.goTypeFromProperty(propType)
		if typeName == "" {
			typeName = "interface{}"
		}
		entry := propertyEntry{
			Name: exportedName(member.Name),
			Type: typeName,
			Tag:  fmt.Sprintf("`json:\"%s\"`", member.Name),
		}
		result = append(result, entry)
	}
	return result, nil
}

func embeddedType(classNode ast.Class) string {
	if classNode.Parent == nil {
		return ""
	}
	return exportedName(classNode.Parent.QualifiedName)
}

func writeImportBlock(builder *strings.Builder, imports []string) {
	builder.WriteString("import (\n")
	for _, path := range imports {
		builder.WriteString(fmt.Sprintf("\t%q\n", path))
	}
	builder.WriteString(")\n")
}

func writeConstBlock(builder *strings.Builder, entries []constEntry) {
	if len(entries) == 1 {
		entry := entries[0]
		builder.WriteString(fmt.Sprintf("const %s %s = %s\n", entry.Name, entry.Type, entry.Value))
		return
	}
	builder.WriteString("const (\n")
	for _, entry := range entries {
		builder.WriteString(fmt.Sprintf("\t%s %s = %s\n", entry.Name, entry.Type, entry.Value))
	}
	builder.WriteString(")\n")
}

func writeStruct(builder *strings.Builder, className string, embedded string, properties []propertyEntry) {
	builder.WriteString("type " + exportedName(className) + " struct {\n")
	if embedded != "" {
		builder.WriteString("\t" + exportedName(embedded) + "\n")
	}
	for _, property := range properties {
		builder.WriteString(fmt.Sprintf("\t%s %s %s\n", property.Name, property.Type, property.Tag))
	}
	builder.WriteString("}\n")
}

func (goGen *Generator) collectImports(namespace ast.Namespace, classNode ast.Class) []string {
	importSet := make(map[string]struct{})
	for _, using := range namespace.Usings {
		path := strings.Join(using.Segments, "/")
		if path != "" {
			importSet[path] = struct{}{}
		}
	}
	if goGen.classUsesTime(classNode) {
		importSet["time"] = struct{}{}
	}
	result := make([]string, 0, len(importSet))
	for path := range importSet {
		result = append(result, path)
	}
	sort.Strings(result)
	return result
}

func (goGen *Generator) classUsesTime(classNode ast.Class) bool {
	for _, member := range classNode.Members {
		if member.Kind == "property" || member.Kind == "shortProperty" {
			propType, err := member.PropertyType()
			if err == nil && goGen.goTypeFromProperty(propType) == "time.Time" {
				return true
			}
		}
		if member.Kind == "method" {
			if member.ReturnType != nil && goGen.goTypeFromIdentifier(*member.ReturnType) == "time.Time" {
				return true
			}
			for _, argument := range member.Arguments {
				if goGen.goTypeFromIdentifier(argument.Type) == "time.Time" {
					return true
				}
			}
		}
	}
	return false
}

func (goGen *Generator) collectMethods(classNode ast.Class) []string {
	result := make([]string, 0)
	for _, member := range classNode.Members {
		if member.Kind != "method" {
			continue
		}
		rendered := goGen.renderMethod(classNode.Name, member)
		if rendered != "" {
			result = append(result, rendered)
		}
	}
	return result
}
func (goGen *Generator) renderMethod(structName string, member ast.Member) string {
	receiver := receiverName(structName)
	if receiver == "" {
		return ""
	}
	args := goGen.renderArguments(member.Arguments)
	returnSignature := goGen.renderReturnSignature(member.ReturnType)
	body := renderMethodBody(returnSignature)
	builder := new(strings.Builder)
	builder.WriteString(fmt.Sprintf("func (%s *%s) %s(%s)%s {\n", receiver, exportedName(structName), exportedName(member.Name), args, returnSignature.withPrefix()))
	if body != "" {
		builder.WriteString("\t" + body + "\n")
	}
	builder.WriteString("}\n")
	return builder.String()
}

func receiverName(structName string) string {
	if structName == "" {
		return ""
	}
	runes := []rune(structName)
	result := strings.ToLower(string(runes[0]))
	return result
}

func (goGen *Generator) renderArguments(arguments []ast.Argument) string {
	if len(arguments) == 0 {
		return ""
	}
	parts := make([]string, len(arguments))
	for index, argument := range arguments {
		parts[index] = fmt.Sprintf("%s %s", toCamel(argument.Name), goGen.goTypeFromIdentifier(argument.Type))
	}
	return strings.Join(parts, ", ")
}

func toCamel(name string) string {
	if name == "" {
		return ""
	}
	return strings.ToLower(name[:1]) + name[1:]
}

type returnSignature struct {
	name     string
	hasValue bool
}

func (goGen *Generator) renderReturnSignature(identifier *ast.Identifier) returnSignature {
	if identifier == nil {
		return returnSignature{}
	}
	name := goGen.goTypeFromIdentifier(*identifier)
	if name == "" {
		return returnSignature{}
	}
	return returnSignature{name: name, hasValue: true}
}

func (signature returnSignature) withPrefix() string {
	if !signature.hasValue {
		return ""
	}
	return " " + signature.name
}

func renderMethodBody(signature returnSignature) string {
	if !signature.hasValue {
		return ""
	}
	return "return " + defaultValueForType(signature.name)
}

func literalValue(value interface{}) string {
	switch typed := value.(type) {
	case string:
		return fmt.Sprintf("%q", typed)
	case int, int32, int64, uint, uint32, uint64, float32, float64:
		return fmt.Sprintf("%v", typed)
	case bool:
		if typed {
			return "true"
		}
		return "false"
	default:
		return ""
	}
}

func (goGen *Generator) goTypeFromProperty(propType ast.PropertyType) string {
	base := goGen.goTypeFromIdentifier(propType.Type)
	if base == "" {
		return ""
	}
	return applySliceNotation(base, propType.ArrayNotation)
}

func (goGen *Generator) goTypeFromIdentifier(identifier ast.Identifier) string {
	if mapped, ok := goGen.FromPdlType(identifier.QualifiedName); ok && mapped != "" {
		return mapped
	}
	return exportedName(identifier.QualifiedName)
}

func applySliceNotation(base string, notation []string) string {
	result := base
	for range notation {
		result = "[]" + result
	}
	return result
}

func defaultValueForType(name string) string {
	switch name {
	case "string":
		return `""`
	case "int", "int64", "uint", "uint64", "float64":
		return "0"
	case "bool":
		return "false"
	case "time.Time":
		return "time.Time{}"
	default:
		return "nil"
	}
}

func exportedName(name string) string {
	return stringy.New(name).UcFirst()
}

func runGoFmt(path string) error {
	cmd := exec.Command("gofmt", "-w", path)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("gofmt failed for %s: %w", path, err)
	}
	return nil
}
