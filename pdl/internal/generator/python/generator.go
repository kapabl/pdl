package python

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/gobeam/stringy"

	"github.com/kapablanka/pdl/pdl/internal/ast"
	"github.com/kapablanka/pdl/pdl/internal/generator"
)

const generatorName = "python"

var pythonTypeMap = map[string]string{
	generator.TypeString:   "str",
	generator.TypeBool:     "bool",
	generator.TypeInt:      "int",
	generator.TypeUInt:     "int",
	generator.TypeDouble:   "float",
	generator.TypeFunction: "Callable[[], None]",
	generator.TypeObject:   "Dict[str, Any]",
	generator.TypeArray:    "Any",
	generator.TypeVoid:     "None",
}

var pythonImportMap = map[string]importFlags{
	generator.TypeFunction: {callable: true},
	generator.TypeObject:   {dict: true, any: true},
	generator.TypeArray:    {any: true},
}

type Generator struct {
	generator.Base
}

type importFlags struct {
	optional bool
	list     bool
	dict     bool
	any      bool
	callable bool
	field    bool
}

type propertyEntry struct {
	line string
}

func init() {
	generator.Register(generatorName, func(ctx context.Context, document ast.Document, options generator.Options) generator.Generator {
		instance := &Generator{Base: generator.NewBase(pythonTypeMap)}
		instance.Initialize(ctx, document, options)
		return instance
	})
}

func (Generator) Name() string {
	return generatorName
}

func (py *Generator) Generate() error {
	document := py.Document()
	targetDir, prepErr := py.prepareTarget(document.Namespace.Name.Segments)
	if prepErr != nil {
		return prepErr
	}
	handler := func(classNode ast.Class) error {
		return py.writeClassFile(document.Namespace, targetDir, classNode)
	}
	return py.ForEachClass(handler)
}

func (py *Generator) prepareTarget(segments []string) (string, error) {
	root := strings.TrimSpace(py.OutputDir())
	if root == "" {
		return "", fmt.Errorf("python generator requires an output directory")
	}
	current := root
	if err := os.MkdirAll(current, 0o755); err != nil {
		return "", err
	}
	if err := ensureInitFile(current); err != nil {
		return "", err
	}
	for _, segment := range segments {
		current = filepath.Join(current, strings.ToLower(segment))
		if err := os.MkdirAll(current, 0o755); err != nil {
			return "", err
		}
		if err := ensureInitFile(current); err != nil {
			return "", err
		}
	}
	return current, nil
}

func ensureInitFile(dir string) error {
	if dir == "" {
		return nil
	}
	path := filepath.Join(dir, "__init__.py")
	if _, err := os.Stat(path); err == nil {
		return nil
	}
	return os.WriteFile(path, []byte("\"\"\"Generated package.\"\"\"\n"), 0o644)
}

func (py *Generator) writeClassFile(namespace ast.Namespace, targetDir string, classNode ast.Class) error {
	if targetDir == "" {
		return nil
	}
	source, err := py.buildClassSource(namespace, classNode)
	if err != nil {
		return err
	}
	fileName := stringy.New(classNode.Name).SnakeCase().Get() + ".py"
	path := filepath.Join(targetDir, fileName)
	return os.WriteFile(path, []byte(source), 0o644)
}

func (py *Generator) buildClassSource(namespace ast.Namespace, classNode ast.Class) (string, error) {
	props, propFlags, propErr := py.collectProperties(classNode)
	if propErr != nil {
		return "", propErr
	}
	constants := collectConstants(classNode)
	content := &strings.Builder{}
	writeHeader(content)
	writeImports(content, propFlags)
	if len(constants) > 0 {
		writeConstants(content, constants)
		content.WriteString("\n")
	}
	writeClassBlock(content, classNode.Name, props)
	return content.String(), nil
}

func writeHeader(builder *strings.Builder) {
	builder.WriteString("# Code generated by pdlgen. DO NOT EDIT.\n")
	builder.WriteString("from __future__ import annotations\n\n")
}

func writeImports(builder *strings.Builder, flags importFlags) {
	builder.WriteString("from dataclasses import dataclass")
	if flags.field {
		builder.WriteString(", field")
	}
	builder.WriteString("\n")
	names := flags.typingNames()
	if len(names) > 0 {
		builder.WriteString("from typing import ")
		builder.WriteString(strings.Join(names, ", "))
		builder.WriteString("\n")
	}
	builder.WriteString("\n")
}

func (flags importFlags) typingNames() []string {
	names := make([]string, 0, 5)
	if flags.optional {
		names = append(names, "Optional")
	}
	if flags.list {
		names = append(names, "List")
	}
	if flags.dict {
		names = append(names, "Dict")
	}
	if flags.any {
		names = append(names, "Any")
	}
	if flags.callable {
		names = append(names, "Callable")
	}
	sort.Strings(names)
	return names
}

func writeConstants(builder *strings.Builder, entries []string) {
	for _, line := range entries {
		builder.WriteString(line)
		builder.WriteString("\n")
	}
}

func writeClassBlock(builder *strings.Builder, className string, props []propertyEntry) {
	builder.WriteString("@dataclass\n")
	builder.WriteString("class ")
	builder.WriteString(stringy.New(className).PascalCase().Get())
	builder.WriteString(":\n")
	if len(props) == 0 {
		builder.WriteString("    pass\n")
		return
	}
	for _, entry := range props {
		builder.WriteString(entry.line)
		builder.WriteString("\n")
	}
}

func (py *Generator) collectProperties(classNode ast.Class) ([]propertyEntry, importFlags, error) {
	result := make([]propertyEntry, 0)
	var flags importFlags
	for _, member := range classNode.Members {
		if !generator.IsPropertyMember(member) {
			continue
		}
		propType, err := member.PropertyType()
		if err != nil {
			return result, flags, err
		}
		entry, entryFlags := py.buildProperty(member.Name, propType)
		result = append(result, entry)
		flags.merge(entryFlags)
	}
	return result, flags, nil
}

func (py *Generator) buildProperty(name string, propType ast.PropertyType) (propertyEntry, importFlags) {
	snake := stringy.New(name).SnakeCase().Get()
	annotation, defaultValue, flags := py.propertySignature(propType)
	line := "    " + snake + ": " + annotation + " = " + defaultValue
	return propertyEntry{line: line}, flags
}

func (py *Generator) propertySignature(propType ast.PropertyType) (string, string, importFlags) {
	baseName, baseFlags := py.baseType(propType.Type)
	depth := len(propType.ArrayNotation)
	if strings.EqualFold(propType.Type.QualifiedName, generator.TypeArray) {
		depth++
	}
	if depth > 0 {
		baseFlags.list = true
		baseFlags.field = true
		annotation := wrapList(baseName, depth)
		return annotation, "field(default_factory=list)", baseFlags
	}
	baseFlags.optional = true
	annotation := "Optional[" + baseName + "]"
	return annotation, "None", baseFlags
}

func wrapList(base string, depth int) string {
	result := base
	for index := 0; index < depth; index++ {
		result = "List[" + result + "]"
	}
	return result
}

func (py *Generator) baseType(identifier ast.Identifier) (string, importFlags) {
	if mapped, ok := py.FromPdlType(identifier.QualifiedName); ok && mapped != "" {
		flags := pythonImportMap[strings.ToLower(identifier.QualifiedName)]
		if mapped == "Any" {
			flags.any = true
		}
		return mapped, flags
	}
	name := generator.SimpleName(identifier.QualifiedName)
	if name == "" {
		name = "Any"
		return name, importFlags{any: true}
	}
	return name, importFlags{}
}

func collectConstants(classNode ast.Class) []string {
	result := make([]string, 0)
	for _, member := range classNode.Members {
		if member.Kind != "const" {
			continue
		}
		value := pythonLiteral(member.Value)
		if value == "" {
			continue
		}
		name := generator.SnakeCaseUpper(member.Name)
		result = append(result, name+" = "+value)
	}
	return result
}

func pythonLiteral(value interface{}) string {
	switch typed := value.(type) {
	case string:
		return strconv.Quote(typed)
	case int, int32, int64, uint, uint32, uint64, float32, float64:
		return fmt.Sprintf("%v", typed)
	case bool:
		if typed {
			return "True"
		}
		return "False"
	default:
		return ""
	}
}

func (flags *importFlags) merge(other importFlags) {
	if other.optional {
		flags.optional = true
	}
	if other.list {
		flags.list = true
	}
	if other.dict {
		flags.dict = true
	}
	if other.any {
		flags.any = true
	}
	if other.callable {
		flags.callable = true
	}
	if other.field {
		flags.field = true
	}
}
