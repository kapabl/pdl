package typescript

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/kapablanka/pdl/pdl/internal/ast"
	"github.com/kapablanka/pdl/pdl/internal/generator"
)

const generatorName = "typescript"

var typescriptTypeMap = map[string]string{
	generator.TypeString:   "string",
	generator.TypeBool:     "boolean",
	generator.TypeInt:      "number",
	generator.TypeUInt:     "number",
	generator.TypeDouble:   "number",
	generator.TypeArray:    "any[]",
	generator.TypeFunction: "Function",
	generator.TypeObject:   "any",
	generator.TypeVoid:     "void",
}

type Generator struct {
	generator.Base
}

func init() {
	generator.Register(generatorName, func(ctx context.Context, document ast.Document, options generator.Options) generator.Generator {
		instance := &Generator{Base: generator.NewBase(typescriptTypeMap)}
		instance.Initialize(ctx, document, options)
		return instance
	})
}

func (Generator) Name() string {
	result := generatorName
	return result
}

func (tsGen *Generator) Generate() error {
	document := tsGen.Document()
	namespaceSegments := document.Namespace.Name.Segments
	classDir := filepath.Join(append([]string{tsGen.OutputDir()}, namespaceSegments...)...)
	if err := tsGen.EnsureDir(classDir); err != nil {
		return err
	}
	handler := func(classNode ast.Class) error {
		return tsGen.generateClassFile(classDir, classNode)
	}
	return tsGen.ForEachClass(handler)
}

func (tsGen *Generator) generateClassFile(classDir string, classNode ast.Class) error {
	var result error
	properties, extractErr := extractProperties(classNode)
	if extractErr != nil {
		result = extractErr
		return result
	}
	content := renderInterface(classNode.Name, properties)
	targetPath := filepath.Join(classDir, classNode.Name+".ts")
	tsGen.WriteFile(targetPath, []byte(content))
	return result
}

type propertyModel struct {
	Name string
	Type string
}

func extractProperties(classNode ast.Class) ([]propertyModel, error) {
	result := make([]propertyModel, 0)
	for _, member := range classNode.Members {
		if member.Kind != "property" && member.Kind != "shortProperty" {
			continue
		}
		propType, err := member.PropertyType()
		if err != nil {
			return result, err
		}
		tsType := mapType(propType)
		result = append(result, propertyModel{Name: member.Name, Type: tsType})
	}
	return result, nil
}

func mapType(propType ast.PropertyType) string {
	result := "any"
	base := strings.ToLower(propType.Type.QualifiedName)
	switch base {
	case "string":
		result = applyArraySuffix("string", propType.ArrayNotation)
	case "int", "int32", "int64", "double", "decimal", "float":
		result = applyArraySuffix("number", propType.ArrayNotation)
	case "bool", "boolean":
		result = applyArraySuffix("boolean", propType.ArrayNotation)
	default:
		result = applyArraySuffix(result, propType.ArrayNotation)
	}
	return result
}

func applyArraySuffix(base string, notation []string) string {
	result := base
	if len(notation) == 0 {
		return result
	}
	for range notation {
		result += "[]"
	}
	return result
}

func renderInterface(name string, properties []propertyModel) string {
	var builder strings.Builder
	builder.WriteString("// Code generated by pdlgen. DO NOT EDIT.\n")
	builder.WriteString(fmt.Sprintf("export interface %s {\n", name))
	for _, property := range properties {
		builder.WriteString(fmt.Sprintf("  %s: %s;\n", property.Name, property.Type))
	}
	builder.WriteString("}\n")
	result := builder.String()
	return result
}
