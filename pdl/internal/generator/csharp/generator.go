package csharp

import (
	"context"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/gobeam/stringy"

	"github.com/kapablanka/pdl/pdl/internal/ast"
	"github.com/kapablanka/pdl/pdl/internal/generator"
)

const generatorName = "csharp"

var csharpTypeMap = map[string]string{
	generator.TypeString:   "string",
	generator.TypeBool:     "bool?",
	generator.TypeDouble:   "double?",
	generator.TypeInt:      "int?",
	generator.TypeUInt:     "uint?",
	generator.TypeObject:   "object",
	generator.TypeArray:    "object[]",
	generator.TypeFunction: "Action",
	generator.TypeVoid:     "void",
}

type Generator struct {
	generator.Base
}

func init() {
	generator.Register(generatorName, func(ctx context.Context, document ast.Document, options generator.Options) generator.Generator {
		instance := &Generator{Base: generator.NewBase(csharpTypeMap)}
		instance.Initialize(ctx, document, options)
		return instance
	})
}

func (Generator) Name() string {
	return generatorName
}

func (csGen *Generator) Generate() error {
	document := csGen.Document()
	if !generator.ShouldGenerateNamespace(document.Namespace, "com") {
		return nil
	}
	outputDir := csGen.OutputDir()
	namespace := document.Namespace
	handler := func(classNode ast.Class) error {
		return csGen.generateClass(namespace, outputDir, classNode)
	}
	return csGen.ForEachClass(handler)
}

func (csGen *Generator) generateClass(namespace ast.Namespace, outputDir string, classNode ast.Class) error {
	var result error
	classSource, buildErr := csGen.renderClass(namespace, classNode)
	if buildErr != nil {
		result = buildErr
		return result
	}
	namespacePath := csharpNamespacePath(namespace)
	targetPath := csharpTargetPath(outputDir, namespacePath, classNode.Name)
	csGen.WriteFile(targetPath, []byte(classSource))
	return result
}

func (csGen *Generator) renderClass(namespace ast.Namespace, classNode ast.Class) (string, error) {
	result := ""
	namespaceQualified := csharpNamespaceQualified(namespace)
	propertyLines, propertyErr := csGen.buildPropertyLines(classNode)
	if propertyErr != nil {
		return result, propertyErr
	}
	constLines, constErr := csGen.buildConstLines(classNode)
	if constErr != nil {
		return result, constErr
	}
	parentClause := csharpParentClause(classNode)
	fullName := csharpFullName(namespaceQualified, classNode.Name)
	body := composeClassBody(classNode.Name, parentClause, fullName, constLines, propertyLines)
	header := "// Code generated by pdlgen. DO NOT EDIT.\n\nnamespace " + namespaceQualified + "\n{\n"
	return header + body + "}\n", nil
}

func composeClassBody(className string, parentClause string, fullName string, constLines []string, propertyLines []string) string {
	builder := new(strings.Builder)
	builder.WriteString("    /// <summary>\n")
	builder.WriteString("    /// PDL Compiler generated class for " + fullName + "\n")
	builder.WriteString("    /// </summary>\n")
	builder.WriteString("    public class " + className)
	if parentClause != "" {
		builder.WriteString(" : " + parentClause)
	}
	builder.WriteString("\n    {\n")
	if len(constLines) > 0 {
		builder.WriteString(indentLines(constLines, "        "))
		if len(propertyLines) > 0 {
			builder.WriteString("\n\n")
		} else {
			builder.WriteString("\n")
		}
	}
	if len(propertyLines) > 0 {
		builder.WriteString(indentLines(propertyLines, "        "))
		builder.WriteString("\n")
	}
	builder.WriteString("    }\n")
	return builder.String()
}

func (csGen *Generator) buildPropertyLines(classNode ast.Class) ([]string, error) {
	result := make([]string, 0)
	for _, member := range classNode.Members {
		if !generator.IsPropertyMember(member) {
			continue
		}
		propertyType, typeErr := member.PropertyType()
		if typeErr != nil {
			return result, typeErr
		}
		typeName := csGen.csharpPropertyType(propertyType)
		propertyName := stringy.New(member.Name).PascalCase().Get()
		result = append(result, "public "+typeName+" "+propertyName+" { get; set; }")
	}
	return result, nil
}

func (csGen *Generator) buildConstLines(classNode ast.Class) ([]string, error) {
	result := make([]string, 0)
	for _, member := range classNode.Members {
		if member.Kind != "const" {
			continue
		}
		constType, typeErr := member.ConstType()
		if typeErr != nil {
			return result, typeErr
		}
		typeName := csGen.csharpTypeName(constType)
		literal := csharpLiteral(member.Value)
		result = append(result, "public const "+typeName+" "+stringy.New(member.Name).PascalCase().Get()+" = "+literal+";")
	}
	return result, nil
}

func csharpParentClause(classNode ast.Class) string {
	if classNode.Parent == nil {
		return ""
	}
	parentType := csharpIdentifierReference(*classNode.Parent)
	return parentType
}

func csharpFullName(namespaceQualified string, className string) string {
	if namespaceQualified == "" {
		return className
	}
	return namespaceQualified + "." + className
}

func (csGen *Generator) csharpPropertyType(propertyType ast.PropertyType) string {
	baseType := csGen.csharpTypeName(propertyType.Type)
	if len(propertyType.ArrayNotation) == 0 {
		return baseType
	}
	builder := new(strings.Builder)
	builder.WriteString(baseType)
	for range propertyType.ArrayNotation {
		builder.WriteString("[]")
	}
	return builder.String()
}

func (csGen *Generator) csharpTypeName(identifier ast.Identifier) string {
	mapped, exists := csGen.FromPdlType(identifier.QualifiedName)
	if exists {
		return mapped
	}
	if len(identifier.Segments) == 0 {
		return identifier.QualifiedName
	}
	segments := make([]string, 0, len(identifier.Segments))
	for _, segment := range identifier.Segments {
		segments = append(segments, stringy.New(segment).PascalCase().Get())
	}
	return strings.Join(segments, ".")
}

func csharpIdentifierReference(identifier ast.Identifier) string {
	if len(identifier.Segments) == 0 {
		return identifier.QualifiedName
	}
	segments := make([]string, 0, len(identifier.Segments))
	for _, segment := range identifier.Segments {
		segments = append(segments, stringy.New(segment).PascalCase().Get())
	}
	return strings.Join(segments, ".")
}

func csharpNamespacePath(namespace ast.Namespace) string {
	if len(namespace.Name.Segments) == 0 {
		return ""
	}
	segments := make([]string, 0, len(namespace.Name.Segments))
	for _, segment := range namespace.Name.Segments {
		segments = append(segments, stringy.New(segment).PascalCase().Get())
	}
	return filepath.Join(segments...)
}

func csharpNamespaceQualified(namespace ast.Namespace) string {
	if len(namespace.Name.Segments) == 0 {
		return ""
	}
	segments := make([]string, 0, len(namespace.Name.Segments))
	for _, segment := range namespace.Name.Segments {
		segments = append(segments, stringy.New(segment).PascalCase().Get())
	}
	return strings.Join(segments, ".")
}

func csharpTargetPath(baseDir string, namespacePath string, className string) string {
	root := filepath.Join(baseDir, "src")
	if namespacePath != "" {
		root = filepath.Join(root, namespacePath)
	}
	return filepath.Join(root, className+".cs")
}
func csharpLiteral(value interface{}) string {
	switch typed := value.(type) {
	case string:
		return strconv.Quote(typed)
	case bool:
		if typed {
			return "true"
		}
		return "false"
	case float64:
		return strings.TrimRight(strings.TrimRight(fmt.Sprintf("%f", typed), "0"), ".")
	default:
		return fmt.Sprint(value)
	}
}

func indentLines(lines []string, indent string) string {
	if len(lines) == 0 {
		return ""
	}
	builder := new(strings.Builder)
	for index, line := range lines {
		if index > 0 {
			builder.WriteString("\n")
		}
		builder.WriteString(indent + line)
	}
	return builder.String()
}
